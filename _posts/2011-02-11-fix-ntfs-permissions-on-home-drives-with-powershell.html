---
layout: post
title: Fix NTFS Permissions on Home Drives with PowerShell
date: 2011-02-11 19:36:22.000000000 +11:00
type: post
published: true
status: publish
categories:
- Technology
tags:
- File Services
- Microsoft
- PowerShell
- Scripting
- tips
- windows
meta:
  _sexybookmarks_shortUrl: http://fla.im/h8FwGk
  _sexybookmarks_permaHash: f453b97be59314847169e4e63d7394b4
  dsq_thread_id: '228763143'
  _jd_tweet_this: 'yes'
  _jd_twitter: ''
  _wp_jd_clig: ''
  _wp_jd_bitly: ''
  _wp_jd_wp: ''
  _wp_jd_yourls: ''
  _wp_jd_url: ''
  _wp_jd_target: ''
  _jd_wp_twitter: ''
  _jd_post_meta_fixed: 'true'
  _edit_last: '1'
  robotsmeta: index,follow
  _syntaxhighlighter_encoded: '1'
author:
  login: chris
  email: chris@flamingkeys.com
  display_name: Chris
  first_name: Chris
  last_name: Brown
---
<p>Keeping permissions in check for your users’ home drives can be a pain at times. I’m a big fan of the <span style="text-decoration: underline;">\\server\share$\username</span> model. This keeps it simple, and allows for easy migration of users between servers.</p>
<p>The problem with home drives is that <a href="http://en.wikipedia.org/wiki/NTFS" target="_blank">NTFS</a> permissions can often (accidently..or intentionally) be changed. In order to maintain appropriate security and accessibility, it’s often desirable to regularly keep these current. I have developed a small script to do this. It collects the name of the folder and attempts to grant permissions to a user in the domain by that same name.</p>
<p>I use this regularly to keep our three file servers of home drives current, and it works very effectively.</p>
<p>UPDATE: Thanks to reader 'Noel' for pointing out a fault with the  $inheritanceFlags and$propagationFlags variables. I've updated the script to suit</p>
<p>[ps]#############################################################################<br />
# Script: Repair-HomeFolderPermissions.ps1<br />
# Author: Chris Brown    http://www.flamingkeys.com<br />
# Date: 20/10/2010<br />
# Keywords:<br />
# Comments:<br />
# Pre-Requisites: Full Control over destination folder.<br />
#<br />
# +------------+-----+---------------------------------------------------------+<br />
# |       Date | Usr | Description                                             |<br />
# +------------+-----+---------------------------------------------------------+<br />
# | 20/10/2010 | CJB | Initial Script                                          |<br />
# | 28/09/2011 | CJB | Fixed flags issue                                       |<br />
# +------------+-----+---------------------------------------------------------+<br />
#<br />
# DISCLAIMER<br />
# ==========<br />
# THIS CODE IS MADE AVAILABLE AS IS, WITHOUT WARRANTY OF ANY KIND. THE ENTIRE<br />
# RISK OF THE USE OR THE RESULTS FROM THE USE OF THIS CODE REMAINS WITH THE USER.<br />
#############################################################################</p>
<p># ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠<br />
#            Variables<br />
#<br />
# Where is the root of the home drives?<br />
$homeDrivesDir=&quot;\\msfs01\home$&quot;<br />
# Report only? ($false = fix problems)<br />
$reportMode = $false<br />
# Print all valid directories?<br />
$verbose = $false<br />
# What domain are your users in?<br />
$domainName = &quot;corp.msft&quot;<br />
#<br />
# ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠ ♥ ♦ ♣ ♠</p>
<p># Save the current working directory before we change it (purely for convenience)<br />
pushd .<br />
# Change to the location of the home drives<br />
set-location $homeDrivesDir</p>
<p># Warn the user if we will be fixing or just reporting on problems<br />
write-host &quot;&quot;</p>
<p>if ($reportMode) {<br />
 Write-Host &quot;Report mode is on. Not fixing problems&quot;<br />
} else {<br />
 Write-Host &quot;Report mode is off. Will fix problems&quot;<br />
}</p>
<p>write-host &quot;&quot;</p>
<p># Initialise a few counter variables. Only useful for multiple executions from the same session<br />
$goodPermissions = $unfixablePermissions = $fixedPermissions = $badPermissions = 0<br />
$failedFolders = @()</p>
<p># For every folder in the $homeDrivesDir folder<br />
foreach($homeFolder in (Get-ChildItem $homeDrivesDir | Where {$_.psIsContainer -eq $true})) {</p>
<p> # dump the current ACL in a variable<br />
 $Acl = Get-Acl $homeFolder</p>
<p> # create a permission mask in the form of DOMAIN\Username where Username=foldername<br />
 #    (adjust as necessary if your home folders are not exactly your usernames)<br />
 $compareString = &quot;*&quot; + $domainName + &quot;\&quot; + $homeFolder.Name + &quot; Allow  FullControl*&quot;</p>
<p> # if the permission mask is in the ACL<br />
 if ($Acl.AccessToString -like $compareString) {</p>
<p> # everything's good, increment the counter and move on.<br />
 if ($verbose) {Write-Host &quot;Permissions are valid for&quot; $homeFolder.Name -backgroundcolor green -foregroundcolor white}<br />
 $goodPermissions += 1</p>
<p> } else {<br />
 # Permissions are invalid, either fix or report<br />
 # increment the number of permissions needing repair<br />
 $badPermissions += 1<br />
 # if we're in report mode<br />
 if ($reportMode -eq $true) {<br />
 # reportmode is on, don't do anything<br />
 Write-Host &quot;Permissions not valid for&quot; $homeFolder.Name -backgroundcolor red -foregroundcolor white<br />
 } else {<br />
 # reportmode is off, fix the permissions<br />
 Write-Host &quot;Setting permissions for&quot; $homeFolder.Name -foregroundcolor white -backgroundcolor red<br />
 # Add the user in format DOMAIN\Username<br />
 $username = $domainName + &quot;\&quot; + $homeFolder.Name<br />
 # Grant the user full control<br />
 $accessLevel = &quot;FullControl&quot;<br />
 # Should permissions be inherited from above?<br />
 $inheritanceFlags = &quot;ContainerInherit, ObjectInherit&quot;<br />
 # Should permissions propagate to below?<br />
 $propagationFlags = &quot;None&quot;<br />
 # Is this an Allow/Deny entry?<br />
 $accessControlType = &quot;Allow&quot;<br />
 try {<br />
 # Create the Access Rule<br />
 $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($username,$accessLevel,$inheritanceFlags,$propagationFlags,$accessControlType)</p>
<p> # Attempt to apply the access rule to the ACL<br />
 $Acl.SetAccessRule($accessRule)<br />
 Set-Acl $homeFolder $Acl<br />
 # if it hasn't errored out by now, increment the counter<br />
 $fixedPermissions += 1<br />
 } catch {<br />
 # It failed!<br />
 # Increment the fail count<br />
 $unfixablePermissions += 1<br />
 # and add the folder to the list of failed folders<br />
 $failedFolders += $homeFolder<br />
 }<br />
 } #/if<br />
 } #/if<br />
} #/foreach</p>
<p># Print out a summary</p>
<p>Write-Host &quot;&quot;<br />
Write-Host $goodPermissions &quot;valid permissions&quot;<br />
Write-Host $badPermissions &quot;permissions needing repair&quot;<br />
if ($reportMode -eq $false) {Write-Host $fixedPermissions &quot;permissions fixed&quot;}<br />
if ($unfixablePermissions -gt 0) {<br />
 Write-Host $unfixablePermissions &quot;ACLs could not be repaired.&quot;<br />
 foreach ($folder in $failedFolders) {Write-Host &quot; -&quot; $folder}<br />
}</p>
<p># Cleanup<br />
popd[/ps]</p>
